---
title:  "4장 Syntax Analysis 3"
categories: compiler
tag: [theory,compiler]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

# Syntax Analysis(Parser)

## BOTTOM-UP Parsing

입력의 terminal을 보고 거꾸로 tree 생성, <span style='color:red'>start symbol</span>까지 생성   
leaf node에서 부터 root로 역으로 진행   
<span style='color:red'>**Right Most Derivation(RM)**</span>을 역순으로 진행   
<span style='color:red'>**LR(Left to right Right most derivation)**</span>   
<span style='color:red'>**Reduction**</span> : derivation의 반대, 즉, start symbol까지 거꾸로 진행   
ex)   
RM derivation : E &rarr; T &rarr; T * F &rarr; T * id &rarr; F * id &rarr; id * id   
RM의 역으로 진행   
![bottomup_example1](../../assets/images/compiler/2023-07-20-chapter7/bottomup_example1.jpg)

### Handle

<span style='color:blue'>Reduction의 과정</span>   
S &rarr; $*_{rm} \alpha Aw &rarr;  rm \; \alpha \beta w$ 이때, $A &rarr; \beta$의 존재가 필요  
$\alpha$는 $\alpha \beta w$의 **Handle**   
example)   

| **Right Form** | **Handle** |  **Reducing**  |
| :------------: | :--------: | :------------: |
| $id_1 * id_2$  |   $id_1$   |  F &rarr; id   |
|   F * $id_2$   |     F      |   T &rarr; F   |
|   T * $id_2$   |   $id_2$   |  F &rarr; id   |
|     T * F      |   T * F    | T &rarr; T * F |
|       T        |     T      |   E &rarr; T   |

<span style='color:red'>**&uarr; : Derivation**</span>   
<span style='color:red'>**&darr; : Reduction**</span>     
<span style='color:blue'>**Handle : reduction을 하기위한 symbol(대상 symbol)**</span>    
<span style='color:blue'>**Reducing : symbol을 만들 수 있는 production rule을 찾음**</span>     
<span style='color:blue'>**이때까지의 과정을 저장하기 위해 stack이 필요**</span>     

Right Most Derivation : $ S = \gamma_0 &rarr; \gamma_1 &rarr; ... &rarr; \gamma_n \; = \; w$    
Algorithm

```c++
for i = n downto 1
    1. find the handle Ai → Bi in ri
    2. replace Bi with Ai to generate ri-1
```

Bottom-up Parsing example)   
![bottomup_example2](../../assets/images/compiler/2023-07-20-chapter7/bottomup_example2.jpg)

### Shift-Reduce Parsing( LR(0) )

<span style='color:blue'>**Handle을 잘찾는 방법**</span>   
이미 처리한 것들을 저장하기 위한 **stack**이 필요   

```python
1. initialize stack with $
2. Repeat until the top of the stack is the goal symbol(start symbol) and the input token is $ → top이 start symbol일 때까지 handle 처리
	a) find the handle
      if we don't have a handle on top of the stack, shift an input wymbol onto the stack
    b) prune the handle(=reduction)
    if we have a handle A → B on the stack, reduce
       i) pop B symbols off the stack
       ii) push A onto the stack
```

#### Shift-Reduce parser Actions

1. shift : 해당 위치의 input을 stack에 넣은 후 ,shift
2. reduce : top을 pop 후, handle을 적용 후 다시 push
3. accept : goal symbol에 도달
4. error : error recovery routine을 call


#### example   
$id_1 * id_2$   
E &rarr; E + T | T   
T &rarr; T * F | F   
F &rarr; ( E ) | id   

|        Stack         |               Input               |                            Action                            |
| :------------------: | :-------------------------------: | :----------------------------------------------------------: |
|          $           | id<sub>1</sub> * id<sub>2</sub> $ |                       shift (and push)                       |
|   $ id<sub>1</sub>   |        * id<sub>2</sub> $         |                    Reduce by F &rarr; id                     |
|         $ F          |        * id<sub>2</sub> $         |                     Reduce by T &rarr; F                     |
|         $ T          |        * id<sub>2</sub> $         |                       shift (and push)                       |
|        $ T *         |         id<sub>2</sub> $          |                       shift (and push)                       |
| $ T * id<sub>2</sub> |                 $                 |                    Reduce by F &rarr; id                     |
|       $ T * F        |                 $                 |                   Reduce by T &rarr; T * F                   |
|         $ T          |                 $                 |                     Reduce by E &rarr; T                     |
|         $ E          |                 $                 | accept (<span style='color:red'>goal symbol = start symbol</span>) |

#### Conflicts

할 수 있는 행동이 여러개일 때, 어떤 행동을 선택하느냐   
shift / reduce conflict : shift와 reduce 모두 가능할 때, e.g. If then if then else   
reduce/ reduce : 어떤 reduce를 할지, e.g. if(id)   
해결법 : **LOOKAHEAD**   
LR(k) : k lookahead symbol을 더 봄, k개의 lookahead를 이용   
보통 LR = LR(1)을 이용   
### SIMPLE LR( SLR )
