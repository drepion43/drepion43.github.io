---
title:  "4장 Syntax Analysis 2"
categories: compiler
tag: [theory,compiler]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

# Syntax Analysis(Parser)

## Top-down Parsing

Algorithm   
```python
1. root node(start symbol) 생성
2. labeled된 node A에 lhs(left hand side)나 rhs(right hand side) production rule을 적용해 확장, A->...
3. terminal이 fringe에 들어왔을 때, symbol과 matching 안된다면 다시 backtrack, 이때 terminal에선 멈추고, non-terminal인 경우 계속 진행
4. 다음 노드로 확장
5. terminal까지 진행, tree 생성 완성
```

### Recursive-Descent Parsing( = LL(0) )

Pseudo Code

```python
'''non-terminal pseudo code'''
void A(){
    Choose an A-production, A -> X1X2...Xk;
    for(i=1 to k){
        if(Xi is a non-terminal)
        	call procedure Xi();
        else if(Xi equals the current input symbol a)
        	advance the input to the next symbol;
        else # an error has occured;
        	# terminal인데 input symbol과 매칭이 안된 경우,
        	# ①없는 symbol(error) ② 다른 production rule로 check
    }
}
```

<span style='color:red'>**1개씩 넣어 확인하는 Parsing 방법**</span>    
여러개의 production rule일 때, 비효율적 &rarr; <span style='color:red'>predictive parsing</span>으로 해결 가능    
(A의 production이 없을 때, error을 handle하니 비효율적 &rarr; 해결 : <span style='color:red'>Predictive Parsing( LL(1) )</span>)   
Non-terminal이 들어올시 위의 Non-terminal 함수를 계속 call   
만약, A &rarr; X<sub>1</sub> | X<sub>2</sub> | X<sub>3</sub> | ... 많은 rule이 있을 때, <span style='color:red'>backtracking</span>이 많이 발생할 수 있음    
example 1)   
   ![LL(0) ex1](../../assets/images/compiler/2023-07-19-chapter6/LL(0) ex1.jpg)
example 2)   
Grammar $G = ({E}, {+, *, (, ), -, id }, P, E)$   
![LL(0) ex2](../../assets/images/compiler/2023-07-19-chapter6/LL(0) ex2.jpg)

### Left Factoring

Production Rule을 좀 더 효율적으로 선택   
**공통 문자 묶기**   

#### Replace Production Rule
$A$ &rarr; $\alpha \beta_1$ |  $\alpha \beta_2$ |  $\alpha \beta_3$ | ... |  $\alpha \beta_n$ | $\gamma$   
<span style='color:orange'>의 Production Rule을 변경(Left Factoring) &rarr; **Left Recursion 제거**</span>    
$A$ &rarr; $\alpha A_R$ | $\gamma$   
$A_R$ &rarr; $\beta_1$ | $\beta_2$ | ... | $\beta_n$   

#### Immediate Left-Recursion Elimination

![immediate left-recursion elimination](../../assets/images/compiler/2023-07-19-chapter6/immediate left-recursion elimination.jpg)   
① left-recursion과 상관없는 것들을 앞에 둠   
② right-recursion을 그 뒤에 넣음   

#### Eliminating left recursion

<span style='color:red'>**① No Cycles   
② $\epsilon$-production 제거   
③ immediate left-recursion 사용**</span>  
Algorithm)

```python
'''
	cycle : A -> Bα
	        B -> cB
		    c -> αA
'''
Input : Grammar G with no cycles or ε-productions
Arrange the nonterminals in some order A1, A2, ..., An
for i=1, ..., n do
	for j=1, ..., i-1 do
    	replace each
        	Ai -> Ajγ
        with
        	Ai -> δ1γ | δ2γ | ... | δkγ
        where
        	Aj -> δ1 | δ2 | ... | δk
        enddo
        eliminate the immediate left recurrsion in Ai
enddo
```

<span style='color:red'>**example)**</span>  
A &rarr; BC | a   
B &rarr; CA | Ab   
C &rarr; AB | CC | a   

<span style='color:orange'>i=1</span>,   
nothing   

<span style='color:orange'>i=2(B), j=1(A),</span>   
B &rarr; CA | <u>A</u>b   
B &rarr; CA | <u>BC</u>b | <u>a</u>b   
<span style='color:blue'>(imm)</span>,   
B &rarr; CAB' | abB'   
B' &rarr; CbB' | $\epsilon$   

<span style='color:orange'>i=3(C), j=1(A)</span>,   
C &rarr; <u>A</u>B | CC | a   
C &rarr; BCB | aB | CC | a   

<span style='color:orange'>i=3(C), j=2(B) </span>,   
C &rarr; <u>B</u>CB | aB | CC | a   
C &rarr; <u>C</u>AB'CB | abB'CB | aB | <u>C</u>C | a   
<span style='color:blue'>(imm)</span>,   
C &rarr; abB'CBC' | aBC' | aC'   
C' &rarr; AB'CBC' | CC' | $\epsilon$   

<span style='color:red'>**example 2)**</span>    
Grammar $G = ({E}, {+, *, (, ), -, id }, P, E)$   
<span style='color:orange'>Producion rule</span>    
E &rarr; E + T | T   
T &rarr; T * F | F    
F &rarr; ( E ) | id    

T &rarr; <u>T</u> * F | F   
<span style='color:blue'>(imm)</span>,    
T &rarr; FT'   
T' &rarr; *FT' | $\epsilon$

E &rarr; <u>E</u> + T | T    
<span style='color:blue'>(imm)</span>,   
E &rarr; TE'   
E' &rarr; +TE' | $\epsilon$   

<span style='color:red'>result</span>   
Grammar $G = ({E, E', T, T', F}, {+, *, (, ), -, id }, P, E)$   
E &rarr; TE'   
E' &rarr; +TE' | $\epsilon$    
T &rarr; FT'   
T' &rarr; *FT' | $\epsilon$   
F &rarr; ( E ) | id    

<span style='color:red'>**example 3)**</span>      
S &rarr; <u>S</u>X | <u>S</u>Sb | XS | a   
X &rarr; <u>X</u>b | Sa | b   

S &rarr; XS S' | aS'   
S' &rarr; X S' | Sb S' | $\epsilon$   
X &rarr; <u>X</u>b | <u>X</u>S S'a | aS'a | b   
X &rarr; aS'aX' | bX'    
X' &rarr; bX' | SS'aX' | $\epsilon$    
### Predictive Parsing( = LL(1) )
