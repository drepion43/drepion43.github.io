---
title:  "6,7장 Process Synchronization"
categories: OS
tag: [theory,OS]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---



# Process Synchronization?



### Race Condition

**Race Condition**은 여러 프로세스들이 동시에 데이터에 접근하는 상황에서, 어떤 순서로 데이터에 접근하느냐에 따라 결과 값이 달라질 수 있는 상황

공유자원(fridge)를 동시에 접근할 경우 **Race Condition**이 발생 가능

data consistency를 위해 atomic operation이 필요



example)

```
int count;

fork1{
	count++;
}
fork2{
	count--;
}

```

위의 예시 코드의 경우 count++ 수행 중에 **context switch**가 발생할 수 있음(**Race Condition**)

즉, **atomic operation**이 필요함



### atomic operation

- atomic operation mechanism
  - semaphore
  - spinlock

- atomic operation의 필요 이유
  1. multi-thread programming시 필요
     -> 공유 변수를 많이 사용하기 때문
     -> solution : semaphore, spinloc
     ![multi-thread](https://github.com/garyexplains/examples/assets/84303857/18bc47e4-37e7-4366-900c-0597fcb2487c)
     위의 그림 처럼 어떤 thread가 공유 변수를 사용했는지 알 수가 없음
  
  2. Systemcall
     -> Systemcall을 수행하는 동안에는 둘 다 kernel 주소 공간의 데이터를 접근하여, kernel 주소 공간에서 작업을 수행하는 도중에 CPU를 빼앗으면 **Race Condition**이 발생
     ->  solution :  kernel mode를 수행 중일 땐 CPU가 preempt 되지 않도록 하고, kernel mode에서 user mode로 돌아갈 때 preempt가 되도록 수행![syscall](https://github.com/garyexplains/examples/assets/84303857/3c0e360e-a11a-4f6f-b025-62e5b0703eee)
  
  3. Interrupt
     -> count++와 count-- 모두를 반영하여 기존의 count값을 유지하려 하지만, count++후 interrupt가 발생한다면, count++만 반영될 수 있음
     -> solution : kernel mode의 수행이 끝나기 전에는 Interrupt를 받지 않도록 하는 방법(disable/enable)
  
     ![kernel mode](https://github.com/garyexplains/examples/assets/84303857/9e87a135-60eb-4fd1-8f9d-bc0582e36a10)



### Critial Section(C.S)

**Critical Section**은 코드 상에서 Race condition이 발생할 수 있는 특정 부분

```python
entry
C.S(Ctrictial Section)
exit
```

- 해결하기 위한 방안
  1. Mutual exclusion 보장
     -> C.S에서는 1개의 process만 이용
  2. progress 보장
     -> C.S가 비어있을 때, 대기 중이던 process 입장
  3. bounded waiting 보장
     -> 일정 시간을 대기하다 들어갈 수 있음(대기 시간 제한)



### Synchronization Solution

Critical Section Problem을 해결하기 위한 알고리즘

2개의 프로세스 존재 : Pi, Pj

1. Peterson's Solution

   - 3개의 property를 보장(turn, flag[0], flag[1])

     ```python
     do{														do{
         flag[i] = True;											flag[j] = False;
         turn = j;												turn = i;
         while(flag[j] & turn==j);								while(flag[i] & turn==i);
         C.S														C.S
         flag[i]=False;											flag[j]=False;
     }while(1);												}while(1)
     ```

     Pi에 대해서 Pi는 flag[i]=True로 변경 후, turn값에 j를 대입, 이때 Pj도 실행되고 있을 때, flag[j]=False, 
