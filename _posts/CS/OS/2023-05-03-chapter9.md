---
title:  "9장 Memory Managment"
categories: OS
tag: [theory,OS]
toc: true
author_profile: false
sidebar:
    nav: "docs"
---

## Memory Managment?











### Swapping

![swapping](https://github.com/drepion43/Coding-Test/assets/84303857/3a11e8ea-3394-4b4f-b912-82f919560efa)

- **Swapping**

  - 프로세스를 일시적으로 메모리에서 Backing Store로 쫓아내는 것

  - **paging과 다르게 프로세스가 통째로 움직임.**

- **Backing Store (Swapping 영억)**

  - 디스크(disk) : 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간

- In / Out

  - 보통 Medium-tern Scheduler(Swapper)에 의해 swap out 시킬 Porcess 선정
  - priority-based CPU scheduling
    - 우선순위가 낮은 Process를 swapping out 시킴
    - 우선순위가 높은 Process를 Memory에 swapping In 시킴

- overhead가 커 가능한 다음 요청할 것을 Keep하는 것이 필요

- example)   
  Latency : 8ms   
  overhead : P1의 크기 / backing store = 10000 KB / 40000KB/s = 250ms    
  time : (250 + 8) x 2(in, out) = 516ms



### Contiguous Allocation

Process를 **contiguous**하게 올림   
Relocation register : Base Address   
Limit Register : Process의 Size   

- Address Translation   
  - **Base Address를 알면 됨(Base + offset)**

- Memory Portection
  - **offset < Process Size 만족시**

- Issue

  1. Hole

     - Memroy에 할당 후 해제시 free한 hole이 발생

     - **Hole Allocation**

       1) First-Fit : 1번째 Hole 선택
       2) Best-Fit : 가장 작은 Hole 선택 (Process size <= Hole Size)
       3) Worst-Fit : 가장 큰 Hole 선택

     - **Fragmentation**

       1. **External Fragmentation**(Contiguous Allocation 때문에 발생)
          - Hole의 크기 총합이 Process보다 크지만, Hole이 분산되어 있어 Memory 할당이 불가능한 경우   
            -> **Compaction** : Hole을 붙여 큰 Hole을 생성

       2.  **Internal Fragmentation**(Unit Size 때문에 발생)
          - 특정 Unit Size보다 못미치는 경우, 남는 공간을 사용못하는 경우



### Paging   

Process의 Virtual Memory (logical memory, V.M)를 동일한 사이즈의 page 단위로 나눔(page : 4KB)   
**Non Contiguous**   
일부는 backing storage에, 일부는 Physical Memory(P.M)에 저장   
보통 Frame(Physical Memory)을 동일한 크기로 나눔   
보통 Page(Virtual Memory)을 동일한 크기로 나눔   
Page와 Frame은 동일한 크기로 두는게 좋음   
Page Table을 사용하여 Virtual Address(V.A)를 Physical Address(P.A)로 변환   
**External Fragmentation 발생 X, Internal Fragmentation 발생 O**

#### Address Translation

![paging 1](https://github.com/drepion43/Coding-Test/assets/84303857/2c02817c-f40f-4ee4-9c7a-3989ae8d7f12)

V.A의 3KB 위치 : 3 = 11(2진수) -> (2^n = 4이니, n=2, m=2)   
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0/ 11(2진수) -> (0: page #, 11 = offset)   
P.A : frame 2번 위치에서 offset 3 더하기(8+3 = 11KB)   
Page # 확인   
Page Table에서 Page # 매핑되는 Frame # 확인   
frame #의 시작 주소 + offset   
![paging 2](https://github.com/drepion43/Coding-Test/assets/84303857/30385574-ea47-4de8-a420-aa155b17dc7b)

- **Page # : logical Address / Page Size**   
- **Offset : logical Address % Page Size**

example)   
Page Size : 2^2 = 4   
2 = 010(m-n = 0, n=10) -> offset: 10=2(n=2 bits), page# = 0(m-n=0 bits)   
Page Table 0번은 5번 Frame   
5 x 2^2 = 20(P.A의 위치), offset=2 -> 22번째 위치   

##### No External Fragmentation(Contiguous X)   

##### Interna Fragmentation(Page Size와 Table Entry 수 trade off)   

##### Frame Table은 P.M이 1개이기 때문에 1개만 존재

##### Page Table은 Process마다 존재



#### Hardware Support

MMU 사용   
*Register*

1. PTBR(Page Table Base Register) : Page Table의 Address를 가지고 있는 Register
2. PTLR(Page Table Length Register) : Page Table의 Size를 가지고 있는 Register   

Register를 Main Memory에서 Page Table를 빠르게 찾을 수 있음
#### TLB

**필요 이유 : Register를 이용시 Memory에 2번 Access해야하니 Overhead가 발생**   
Page Table의 일부를 저장   
몇몇은 TLB에 고정시키기도 함   
빠른 캐쉬 메모리, Associative Memory   
ASIDs(Address-Space-Identifiers) : TLB항목이 어떤 Process에 속한건지 알려주는 기능   
*Mappgin법*

1. TLB Search
2. 존재시, mapping
3. 없을시, Page Table접근 후 mapping

*EAT(Effective Access Time)*

- Hit Ratio : 페이지 번호가 TLB에서 발견되는 비율   
  ![tlb](https://github.com/drepion43/Coding-Test/assets/84303857/06465e9e-174b-4d52-9a42-0b0ab4362ccf)

#### Proection

- Valid(legal), Invalid(illegal) : bit로 확인

#### Shared Pages

- 같은 Frame에 재진입인 경우 코드를 공유 가능
- Memory Space 절약, IPC 로 공유

#### 페이지 테이블의 구조

- **Goal : Page Table Size Down**	
- example)   
  ![page table](https://github.com/drepion43/Coding-Test/assets/84303857/3533a558-3bbd-4a06-a9f5-681b8e1c3595)   
  entry : 2^20개, Process : 2^20 x 4B = 4MB -> Page Table로 4MB 사용

##### Hierarchical Paging

- Goal : Page Table 크기 줄이기

- 2-level Page Table   
  ![hieracal 1](https://github.com/drepion43/Coding-Test/assets/84303857/eea0d447-18d7-402f-b085-977156fa5b54)   
  **Valid인것만 남기고 Invalid인것은 제거(Memory Size Down, Memory Access Time Up)**   

  Linux : 3-level Page Table 사용(64 bits)    

  ![hieracal 2](https://github.com/drepion43/Coding-Test/assets/84303857/7f546a50-d51d-4457-a60c-2b9d76e58d0f)   

##### Hashed Page Table

- Goal : Page Table Size Down
- Hash Function을 사용, Chain이 달림
- example)   
  ![hashed](https://github.com/drepion43/Coding-Test/assets/84303857/1e837deb-f7a1-4999-bd1f-22fbd15e5291)   
  해당 logical의 P로 Frame에 mapping



##### Inverted Page Tables

- **1개의 Page Table만 사용(Process마다 Page Table 존재 X)**
- entry : frame #, PID, Page #
- **Page Table 전체를 Search하니 Search Time이 오래 걸림**
- example)   
  ![inverted](https://github.com/drepion43/Coding-Test/assets/84303857/4c34c842-3a12-4c79-a9a7-5b73e5148aec)   
  PID, Page #가 matching 되어야 Frame # 찾기 가능



### Segmentation

프로그램을 segment 단위로 분할, Contiguous하게 저장   
example)   
![segmentation 1](https://github.com/drepion43/Coding-Test/assets/84303857/e2b975fc-f838-4243-a882-26e5f147dc06)   

- Address Translation : 각각의 segment의 base Address를 알면 됨
- Protection : Option으로 보호기능, 추가 기능

#### Segment Table

segment의 Size : limit   
![segmentation 2](https://github.com/drepion43/Coding-Test/assets/84303857/7cbb6dba-ccb3-474f-ba6f-db39c7cee5ab)   
STBR : Segment Table의 주소 Register   
STLR : Segment Table의 Size(개수)  Register(Segment 개수 < STLB)

#### Issue

**External Fragmentation(Frist, Best, Worst)**

