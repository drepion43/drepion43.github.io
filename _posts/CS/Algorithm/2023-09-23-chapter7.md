---
title:  "7장 Transitive Closure, All-Pairs Shortest Paths"
categories: Algorithm
tag: [theory,Algorithm]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true

---

## Shortest path

① single-source shortest path problem : source만 주어짐 &rarr; Dijkstra   
② single-pair shortest path problem : source와 destination이 주어짐   
③ single-destination shortest path problem : destination만 주어짐  
④ All-pairs shortest path problem : 모든 vertex에 대해 shortest path 구함 &rarr; Floyd-Warshall  

## Transitive Closure

digraph $G$에 대해 transitive closure를 추가한 graph는 $G^\*$   
\- $G$와 $G^\*$는 같은 vertex를 가지고 있음   
\- $G$가 u에서 v로가는($u \ne v$) **directed path**가 존재한다면 $G^\*$는 **directed edge**를 가짐  
![trainsitve closure1](../../../assets/images/Algorithm/2023-09-23-chapter7/trainsitve closure1.jpg){: width="70%" height="70%"}   
Transitive Closure는 n번의 **DFS**를 통해 확인 가능   
A &rarr; C 로가는 direct edge가 없을 때, A &rarr; B &rarr; C 를 통해 갈 수 있다면, A &rarr; C edge를 생성   
<span style='color:blue'>모든 vertex를 starting으로 두어가며 DFS를 통해 확인</span>   
$O(n(n+m))$ time이 발생하며, dense graph인 경우 $O(m) \approx O(n^2)$ 이니 $O(n^3)$ time에 bound   

## Floyd-Warshall

Idea 1 : Number the vertices 1, 2, 3, ... , n (\|v\| = n)   
Idea 2 : 각 vertex들에 대해 갈 수 있는 edge들을 모두 생성   
① i에서 k로 가는 directed edge를 1,2,...,k-1 vertex를 통해 찾음   
② k에서 j까지 가는 edge를 1,2,..., k-1 vertex를 통해 찾음   
③ i에서 j의 directed edge를 생성   
![trainsitve closure2](../../../assets/images/Algorithm/2023-09-23-chapter7/trainsitve closure2.jpg){: width="70%" height="70%"}

### Example

![floyd1](../../../assets/images/Algorithm/2023-09-23-chapter7/floyd1.jpg){: width="70%" height="70%"}   
상기의 그래프에 대해 Floyd Warshall을 적용을 보여줄 거임   
우선 n번의 DFS 적용하며 n개의 vertex에 대해 shortest path를 가져야하니 n x n의 인접 matrix를 표현   

| $G_0$ | 1($G_1$)<br/> <span style='color:blue'>check</span> | 2($G_2$) | 3($G_3$) | 4($G_4$) | 5($G_5$) | 6($G_6$) | 7($G_7$) |
| :---: | :-------------------------------------------------: | :------: | :------: | :------: | :------: | :------: | :------: |
|   1   |                          0                          |    0     |    0     |    1     |    0     |    0     |    0     |
|   2   |                          0                          |    0     |    0     |    0     |    0     |    0     |    0     |
|   3   |                          1                          |    1     |    0     |    1     |    0     |    0     |    0     |
|   4   |                          0                          |    0     |    1     |    0     |    0     |    0     |    0     |
|   5   |                          1                          |    0     |    1     |    0     |    0     |    0     |    0     |
|   6   |                          0                          |    1     |    1     |    0     |    1     |    0     |    1     |
|   7   |                          0                          |    0     |    0     |    0     |    1     |    1     |    0     |

1번째 iteration의 전인 $G_0$ 상기의 matrix이며, 1번 2번으로 표현한 것은 vertex의 번호를 표현한 것임   
우선 $G_0$을 업데이트해야하니, 1열을 보면 \[0, 0, 1, 0, 1, 0, 0\]으로 되어 있으며 3 &rarr; 1 과 5&rarr; 1의 edge가 존재한다는 뜻   
그럼 1번의 행인 \[0, 0, 0, 1, 0, 0, 0\]을 확인해보면 1 &rarr; 4가 존재하니 3 &rarr; 4를 추가해줘야함   
또 5 &rarr; 1의 경우도 존재하니, 5 &rarr; 4를 추가해줘야 함   

| $G_1$ | 1($G_1$) | 2($G_2$)<br/> <span style='color:blue'>check</span> | 3($G_3$) | 4($G_4$) | 5($G_5$) | 6($G_6$) | 7($G_7$) |
| :---: | :------: | :-------------------------------------------------: | :------: | :------: | :------: | :------: | :------: |
|   1   |    0     |                          0                          |    0     |    1     |    0     |    0     |    0     |
|   2   |    0     |                          0                          |    0     |    0     |    0     |    0     |    0     |
|   3   |    1     |                          1                          |    0     |    1     |    0     |    0     |    0     |
|   4   |    0     |                          0                          |    1     |    0     |    0     |    0     |    0     |
|   5   |    1     |                          0                          |    1     |    1     |    0     |    0     |    0     |
|   6   |    0     |                          1                          |    1     |    0     |    1     |    0     |    1     |
|   7   |    0     |                          0                          |    0     |    0     |    1     |    1     |    0     |

1번째 iteration 후인 $G_1$의 state의 matrix임   
2번의 열을 보면 \[0, 0, 1, 0, 0, 1, 0\]으로 되어 있으며 3 &rarr; 2 와 6 &rarr; 2의 edge가 존재   
2번의 행을 보면 \[0, 0, 0, 0, 0, 0, 0\]으로 갈 수 있는 vertex가 없으니 끝  

| $G_2$ | 1($G_1$) | 2($G_2$) | 3($G_3$)<br/> <span style='color:blue'>check</span> | 4($G_4$) | 5($G_5$) | 6($G_6$) | 7($G_7$) |
| :---: | :------: | :------: | :-------------------------------------------------: | :------: | :------: | :------: | :------: |
|   1   |    0     |    0     |                          0                          |    1     |    0     |    0     |    0     |
|   2   |    0     |    0     |                          0                          |    0     |    0     |    0     |    0     |
|   3   |    1     |    1     |                          0                          |    1     |    0     |    0     |    0     |
|   4   |    0     |    0     |                          1                          |    0     |    0     |    0     |    0     |
|   5   |    1     |    0     |                          1                          |    1     |    0     |    0     |    0     |
|   6   |    0     |    1     |                          1                          |    0     |    1     |    0     |    1     |
|   7   |    0     |    0     |                          0                          |    0     |    1     |    1     |    0     |

2번 째 iteration 후인 $G_1$의 state의 matrix임   
3번의 열을 보면 \[0, 0, 0, 1, 1, 1, 0\]으로 되어 있으며 4 &rarr; 3, 5 &rarr; 3, 6 &rarr; 3의 edge가 존재   
ㄴㄴㄴ   
   
그림   
  

### Algorithm

```c++
Algorithm FloydWarshall(G)
    Input digraph G
    Output transitive closure G* of G
    i ← 1
    for all v ∈ G.vertices()
        denote v as v_i
        i ← i + 1
    G_0 ← G // copy, 초기화
	for k ← 1 to n do
        G_k ← G_{k-1}
		for i ← 1 to n (i != k) do
            for j ← 1 to n (j != i, k) do
				//i 부터 k 까지 와 k부터 j까지 확인 
                if G_{k-1}.areAdjacent(v_i, v_k) ∧ G_{k-1}.areAdjacent(v_k, v_j)
					if ¬G_k.areAdjacent(v_i, v_j) // i에서 j까지 directly edge가 없을 때
                        Gk.insertDirectedEdge(v_i, v_j, k)
	return G_n // transitive closure
```

total : $O(n^3)$ time   
areAdjacent : $O(1)$ time &rarr; 인점 행렬로 구현하기 때문   
