---
title:  "1장 Analyzing Algorithms and Problems: Principles and Examples"
categories: Algorithm
tag: [theory,Algorithm]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

## Introduction

### Computer Algorithm

어떤 문제를 해결하기 위해 step by step으로 해결하는 방법   
컴퓨터를 이용해 유한시간 이내로 문제를 해결   
① Problem(문제 정의)   
&rarr; Input : 3, 7, 20, 11 : n개 정수   
&rarr; Output : 3, 7, 11, 20 : n개 정수가 오름차순 정렬   
② Strategy(해결전략)   
③ Algorithm(알고리즘 서술, Pseudo Code)   
&rarr; Input, Output : 문제를 푸는 알고리즘   
&rarr; Step : 문제를 풀기위한 방법들   
④ Analysis(분석)   
&rarr; Correctness(정확하게 작동하는지 확인)   
&rarr; Time & Space Efficiency : Time & Storage Complexity Check   
&rarr; Optimality(최적성) : <span style='color:orange'>알고리즘의 복잡도 = 문제의 복잡도</span>인 경우 Optimality 보장   
⑤ Implementation(구현)   
⑥ Verification(확인 검증)   

#### Decision Tree

preorder 순( n = 10 )   
그림   
<span style='color:blue'>Worst Case : the root to a leaft(root에서부터 가장 긴 path), Search All nodes</span>   
N(All nodes) $\le$ 1 + 2 + 4 + 8 + ... + $2^{p-1}$ = $2^{p} - 1$    
$2^{p} \; \ge \;$ ( N + 1 ) $\ge$ ( n + 1 )    
### Binary Search

```c++
int binarySearch(int[] E, int first, int last, int K){
    if(last < first) // no basic operation, 재귀 탈출 조건 
        index = -1;
    else{
        int mid = (first + last) / 2; // 내림
        if(K == E[mid])
            index = mid;
        else if(K < E[mid])
            index = binarySearch(E, first, mid-1, K); // 좌측으로 범위 감소
        else // K > E[mid]
            index = binarySearch(E, mide+1, last, K); // 우측으로 범위 감소
    }
    return index;
}
```

#### Binary Search Worst Case

Basic Operation : K와 array entry와의 비교 연산   
if, else if, else를 각각의 1개의 연산으로 생각( >, <, ==)   
첫번째 비교 후, K != E[mid]인 경우, array를 두개의 section으로 분할(각 section은 $\lfloor n / 2 \rfloor $의 entry 보유)   
section을 분할을 수행할 때 마다 entry수가 $\lfloor \; n/ 2 \; \rfloor $만큼 감소하는 재귀 호출   
재귀를 통해 entry가 1보다 작아질려면 최대 <span style='color:orange'>n / ( $2^{d}$ ) $\ge$ 1  &rarr; d $\le \; log(n)$</span> 필요     
한번 비교 후 재귀가 일어나니 $log(n) \; + \; 1$이 필요   

<span style='color:red'>**따라서 Worst Case : $W(n) \; = \; \lfloor log \; n \rfloor \; + \; 1 \; = \; \lceil \; log(n+1) \; \rceil \; \in \Theta(log \; n)$**</span>   
e.g. 탐색할 entry 수 : n, $n \;\times \; \frac{1}{2}$, $n \;\times \; (\frac{1}{2})^{2}$, ..., $n \;\times \; (\frac{1}{2})^{k} \; = \; 1$ &rarr; k번 비교 연산, Worst Case의 경우 $2^{k} \; = \; n$이 되고 $k = log_2 \; n$이 됨   
#### Binary Serach Average Case

+ **Assumption**이 필요   
  n : Success, n+1 : Fail    
  ① 모든 Case가 발새할 확률은 동일   
  &rarr; $Pr(I_i \; | \; Succ)\; = \; \frac{1}{n}, Pr(I_i \; | \; Fail)\; = \; \frac{1}{n+1}$   
  ② n이 가장 클 수 있을 때 인 Complete Binary Tree 형태일 때   
  &rarr; ($n \; = \; 2^d \; - \; 1$) &rarr; $d \; = \; log(n+1)$ (d : 비교 연산 수)   
  ③ <span style='color:blue'>모든 entry는 Distinct</span>
+ 계산과정   
    \begin{aligned}
          A(n) \; =& \; Pr(Succ)A_{Succ}(n) \; + \; Pr(Fail)A_{Fail}(n) \newline
          A_{fail}(n) \; =& \; \sum_{i=1}^{n+1}Pr(I_i | Fail) \times t(I_i) \newline
          =& \frac{1}{n+1} \times d(n+1) = d \newline
          =& log(n+1) \newline
          A_Succ(n) \; =& \; \sum_{i=1}^{d}Pr(I_i | Succ) \times t(I_i) \newline
          =& \frac{d \times 2^{d} - (2^{d} - 1)}{n} \newline
          =& \frac{2^{d}(d - 1) + 1}{n} (d = log(n+1)) \newline
          =& \{nlog(n+1) - n + log(n+1)\}\frac{1}{n} \newline
          A(n) \; =& \; q (log(n+1) - 1)\; + \; (1-q)(log(n+1)) \approx log(n+1) - q
    \end{aligned}
  q : 0 $\le$ q $\le$ 1 이고, $A(n) \; \in \; \Theta (log(n))$

### Sequential Search

Input data : sorted array(오름차순)   
Sequential Search : index 0부터 비교하여 해당 값 찾기, k보다 크다면 종료 

```c++
int seqSearchMod(int[] E, int n, int K){
    int ans, index;
    ans = -1; // Assume Fail
    for(index =0; index < n; index++){
        if(K > E[index])
            continue;
        if(K < E[index])
            break; // E에 K값이 없는 경우
        // K == E[index]인 경우
        ans = index;
        break;
    }
    return ans;
}
```

#### Sequential Serach Worst Case

$W(n) \; = \; n + 1 \; \approx \; n$ (n+1의 basic operation 수행)   
0 ~ n-1까지 K > E\[index\]을 n번 수행, K < E\[index\]는 1번 수행   

#### Sequential Search Average Case

\begin{aligned}
    A(n) \; =& \; Pr(Succ)A_{Succ}(n) + Pr(Fail)A_{Fail}(n) \newline
    A_{Succ}(n) \; =& \; \sum_{i=0}^{n-1} Pr(I_i|Succ) \times t(I_i) \newline
    =& \frac{1}{n}(\frac{n(n+1)}{2}) \newline
    =& \frac{n+1}{2} \newline
    A_{Fail}(n) \; =& \; \sum_{i=0}^{n}Pr(I_i | Fail) \times t(I_i) \newline
    =& (i+1)(\frac{1}{n+1}) \; + \; \frac{n}{(n+1)} \newline
    =& \frac{n}{2} + \frac{n}{n+1} \newline
    A(n) \; =& \; q\frac{(1+n)}{2} \; + \; (1-q)(\frac{n}{(n+1)} \; + \; \frac{n}{2}) \newline
    \approx \; \frac{n}{2}
\end{aligned}

### Divde & Conquer
