---
title:  "3장 Sorting"
categories: Algorithm
tag: [theory,Algorithm]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
---

## Sorting Algorithm

|               종류               |                       Worst Case Time                        |
| :------------------------------: | :----------------------------------------------------------: |
|          Insertion Sort          |                           O($n^2$)                           |
|            Quick Sort            |       O($n^2$) &rarr; 기대 수행 시간 : O($n log (n)$)        |
|  Merge Sort(Optimal Algorithm)   |                        O($n log (n)$)                        |
| Heap Sort(**Optimal Algorithm**) |                        O($n log (n)$)                        |
|            Radix Sort            | O($n$) &rarr; Input에 대한 특저 제한 사항이 있을 경우 : O($n$)에 수행 가능 |

unsorted data에 대해서는 모든 data를 살펴봐야하니 optimal solution의 탐색(find)이 $\Theta(n)$   
sorted data에 대해서는 optimal solution의 탐색(find)이 $\Theta(log n)$   

## Insertion Sort

n개의 elements를 가지는 unsorted array에 대해 수행   
두 개의 영역으로 나눔(sorted 영역, unsorted 영역)   
$x$를 밖으로 빼서 사용   
![InsertionSort1](../../../assets/images/Algorithm/2023-09-03-chapter2/InsertionSort1.jpg)   
① $x$를 밖으로 빼놓음   
② $x$와 index 0의 element를 비교 후 $x$가 더 작다면 swap해 $x$를 index 0 위치에 넣음   

### Algorithm

Input : E(element들을 가지는 array), $n \le 1$이며 element들의 수, index는 0, 1, ... , n-1까지 존재   
Output : key들이 오름차순으로 정렬된 array   

```c++
void insertionSort(Element[] E, int n){
    int xindex;
    for(xindex = 1; xindex < n; xindex++){
        Element current = E[xindex];
        key x = current.key;
        int xLoc = shiftVacRec(E, xindex, x);
        E[xLoc] = current;
    }
    return;
}
```

```c++
int shiftVacRec(Element[] E, int vacant, Key x){
    // vacant : index
    int xLoc;
    if(vacant == 0)
        xLoc = vacant;
    else if(E[vacant-1].key <= x) // 전 위치보다 크면 제자리를 찾은 것
        xLoc = vacant;
    else{
        E[vacant] = E[vacant-1]; // 나의 위치를 왼쪽으로 한 칸 이동
        xLoc = shiftVacRec(E, vacant-1, x);
    }
    return xLoc;
}
```

### Example

$E\(array\) \; = \; \<5, 2, 4, 6, 1, 3\>$   
![InsertionSort2](../../../assets/images/Algorithm/2023-09-03-chapter2/InsertionSort2.jpg)   
<span style='color:red'>**loop invariant(Correctness 분석)**</span> : 수학적 귀납법(i = 1, i=k일 때 참 증명시, k+1일 때 증명이 필요),    
① Initalization(초기화)   
&rarr; <span style='color:blue'>index 0까지 sorted 영역</span>   
② maintenance(iteration K가 참일려면, K+1이 참이면 됨)   
&rarr; <span style='color:blue'>i index가 시작되기 전 i-1까지는 sorted된 상태이고 i index가 끝난 후, i까지 sorted되 있는 상태(귀납법)</span>   
③ Termination   
&rarr; <span style='color:blue'>종료 후 sorted 되어있는 상태</span>   

### Analysis

<span style='color:red'>**Worst Case Complexity**</span>    
\begin{aligned}
    W(n) \; =& \; \sum_{i=1}^{n-1} i \; = \; n(n-1)/2 \; \approx \; \frac{n^2}{2} \in \; \Theta(n^2) \; 
\end{aligned}   

<span style='color:red'>**Average Behavior**</span>   
<span style='color:blue'>$ShiftVacRec$ : i번째 element의 위치 찾기</span>   
\begin{aligned}
    1/(i+1)\sum_{j=1}^{i}j \; + \; i/(i+1) \; = \; i/2+1 - 1/(i+1)
\end{aligned}   
총 i+1의 경우가 존재,    
1번의 경우 : x가 적절한 위치에 있어 비교 연산을 sorted된 영역의 가증 큰값과 한번 비교   
i번의 경우 : x가 가장 작은 값이여서 sorted된 영역의 원소들과 모두 비교   

<span style='color:blue'>$Average case$ : $ShiftVacRec$를 전체 원소들에 대해 수행(n-1)번</span>      
\begin{aligned}
    A(n) \; =& \; \sum_{i=1}^{n-1} \{i/2 + 1 - 1/(i+1)\} \approx n^2/4 \; \in \; \Theta(n^2)
\end{aligned}   
### Optimality

두개의 원소를 비교, swap하는 operation이 동작   
worst case의 경우 : $n(n-1)/2$의 비교가 발생   
average case의 경우 : $n(n-1)/4$의 비교가 발생   
<span style='color:blue'>**Insertion sort가 Optimal Algorithm이 되려면 인접한 원소만 비교하고 interchaning을 할 때**</span>   
## Quick Sort

