---
title:  "[백준]15683번"
categories: Coding
tag: [Coding, Coding Test, Baekjoon, Python, Simulation, BFS, DFS, Combination]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
date: 2023-10-13
toc_sticky: true
---

## 감시(15683번)

<https://www.acmicpc.net/problem/15683>

### 문제

스타트링크의 사무실은 1×1크기의 정사각형으로 나누어져 있는 N×M 크기의 직사각형으로 나타낼 수 있다. 사무실에는 총 K개의 CCTV가 설치되어져 있는데, CCTV는 5가지 종류가 있다. 각 CCTV가 감시할 수 있는 방법은 다음과 같다.

| ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/1.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/2.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/3.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/4.png) | ![img](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15683/5.png) |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1번                                                          | 2번                                                          | 3번                                                          | 4번                                                          | 5번                                                          |

1번 CCTV는 한 쪽 방향만 감시할 수 있다. 2번과 3번은 두 방향을 감시할 수 있는데, 2번은 감시하는 방향이 서로 반대방향이어야 하고, 3번은 직각 방향이어야 한다. 4번은 세 방향, 5번은 네 방향을 감시할 수 있다.

CCTV는 감시할 수 있는 방향에 있는 칸 전체를 감시할 수 있다. 사무실에는 벽이 있는데, CCTV는 벽을 통과할 수 없다. CCTV가 감시할 수 없는 영역은 사각지대라고 한다.

CCTV는 회전시킬 수 있는데, 회전은 항상 90도 방향으로 해야 하며, 감시하려고 하는 방향이 가로 또는 세로 방향이어야 한다.

```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 1 0 6 0
0 0 0 0 0 0
```

지도에서 0은 빈 칸, 6은 벽, 1~5는 CCTV의 번호이다. 위의 예시에서 1번의 방향에 따라 감시할 수 있는 영역을 '`#`'로 나타내면 아래와 같다.

| `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 # 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 # # 1 0 6 0 0 0 0 0 0 0` | `0 0 # 0 0 0 0 0 # 0 0 0 0 0 1 0 6 0 0 0 0 0 0 0` | `0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 6 0 0 0 # 0 0 0` |
| ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| →                                                 | ←                                                 | ↑                                                 | ↓                                                 |

CCTV는 벽을 통과할 수 없기 때문에, 1번이 → 방향을 감시하고 있을 때는 6의 오른쪽에 있는 칸을 감시할 수 없다.

```
0 0 0 0 0 0
0 2 0 0 0 0
0 0 0 0 6 0
0 6 0 0 2 0
0 0 0 0 0 0
0 0 0 0 0 5
```

위의 예시에서 감시할 수 있는 방향을 알아보면 아래와 같다.

| `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 0 0 0 0 # # 2 # # # # 0 0 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 # # 2 # 0 0 0 0 0 # # # # # # 5` | `0 # 0 0 0 # 0 2 0 0 0 # 0 # 0 0 6 # 0 6 0 0 2 # 0 0 0 0 # # # # # # # 5` |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↔                             | 왼쪽 상단 2: ↔, 오른쪽 하단 2: ↕                             | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↔                             | 왼쪽 상단 2: ↕, 오른쪽 하단 2: ↕                             |

CCTV는 CCTV를 통과할 수 있다. 아래 예시를 보자.

```
0 0 2 0 3
0 6 0 0 0
0 0 6 6 0
0 0 0 0 0
```

위와 같은 경우에 2의 방향이 ↕ 3의 방향이 ←와 ↓인 경우 감시받는 영역은 다음과 같다.

```
# # 2 # 3
0 6 # 0 #
0 0 6 6 #
0 0 0 0 #
```

사무실의 크기와 상태, 그리고 CCTV의 정보가 주어졌을 때, CCTV의 방향을 적절히 정해서, 사각 지대의 최소 크기를 구하는 프로그램을 작성하시오.

### 입력

첫째 줄에 사무실의 세로 크기 N과 가로 크기 M이 주어진다. (1 ≤ N, M ≤ 8)   
둘째 줄부터 N개의 줄에는 사무실 각 칸의 정보가 주어진다. 0은 빈 칸, 6은 벽, 1~5는 CCTV를 나타내고, 문제에서 설명한 CCTV의 종류이다.    
CCTV의 최대 개수는 8개를 넘지 않는다.


### 해결법

CCTV의 경우 각 90도로 회전하는 방향을 가지고 있음   
1번의 경우 4개의 방향, 2번의 경우 2개의 방향, 3번의 경우 4개의 방향, 4번의 경우 4개의 방향, 5번은 1개의 방향의 모양을 가지고 있음   
이 때 예를 들어 2번은 양방향으로 뻗어가는데, 벽을 만나거나 보드판이 끝날 때까지 계속하여 직진하여 감시를 수행함   
감시를 할 수 있는 곳이라는 의미로 board위에 -1값으로 변경하여 표시를 함 &rarr; 이 뜻은 곳 모든 카메라 감시 구역을 -1로 설정한 후 0의 개수가 사각지대 구역 개수가 된다는 뜻   
카메라 감시 직진은 BFS을 이용하여 한쪽 방향으로만 이동하게 수행함   
각 번호의 카메라는 조합을 이용하여 구현했으며 어떤 방향을 선택했을 때 감시구역 최대\(사각지대 최소\)가 되는 것을 구하면 해결 가능    
즉, 카메라 번호에 따라 갈 수 있는 감시 방향이 정해지는데 선택한 방향으로 감시를 했을 때 최소 사각지대(최대 감시구역)이 되는 감시 방향을 선택하면 됨(조합)


```python
from collections import deque
import copy

# 보드 크기
n, m = map(int, input().split())
# 보드
board = []
# 카메라 : [번호, x좌표, y좌표]
cctvs = []
for x in range(n):
    data = list(map(int, input().split()))
    board.append(data)
    # 카메라 설치 구역인 경우
    for y, y_val in enumerate(data):
        if y_val in [1, 2, 3, 4, 5]:
            cctvs.append([y_val, x, y])

# 이동( 상 하 좌 우)
dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

# 카메라의 경우( 1: ->, 2: <->, 3: ㄴ, 4: ㅗ 5: 모둔 방향)의 경우를 가지고 있음
camera_mode = [
    # 0번은 X
    [],
    # 1번 : 한쪽 방향
    [[0], [1], [2], [3]],
    # 2번 : 양 방향(서로 반대 방향)
    [[0, 1], [2, 3]],
    # 3번 : 직각 모양
    [[0, 2], [0, 3], [1, 2], [1, 3]],
    # 4번 : ㅗ 모양
    [[0, 2, 3], [1, 2, 3], [2, 0, 1], [3, 0, 1]],
    # 5번 : 모든 방향
    [[0, 1, 2, 3]]
]

# 설치된 카메라의 번호에 맞게 해당 카메라에서 감시구역 설정(카메라 모드, x, y)
def monitoring(cctv_mode, cctv_x, cctv_y, _board):
    for d in cctv_mode:
        x, y = cctv_x, cctv_y
        # 갈 수 있는 곳 까지 확장 보드 끝이나 벽을 만날 때 까지
        q = deque()
        q.append([x, y])
        # 한쪽 방향으로 끝까지 이동
        while q:
            x, y = q.popleft()
            nx, ny = x + dx[d], y + dy[d]
            if 0 <= nx < n and 0 <= ny < m:
                # 벽을 만났을 때는 이동 불가
                if _board[nx][ny] == 6:
                    break
                # 카메라가 설치된 구역을 만났을 때는 카메라 설치는 놔두고 다음 구역으로 이동하여 감시
                elif _board[nx][ny] in [1, 2, 3, 4, 5]:
                    q.append([nx, ny])
                # 빈 벽이거나 이미 다른 카메라가 감시 했던 구역일 때는 똑같이 감시를 진행
                else:
                    # -1 값은 감시를 할 수 있다는 구역의 의미
                    _board[nx][ny] = -1
                    q.append([nx, ny])
            else:
                break
# 정답(사각지대 최소 구역)
answer = int(1e9)

# 최대 감시구역을 찾으면 그 때가 사각지대가 최소가 되는 것과 동등한 상태
# 즉, -1 값이 가장 많을 때가 최대 감시 구역이 됨 -> 이 뜻은 0이 가장 작을 때가 사각지대 최소 구역
# 각 카메라를 어떤 방향으로 설정했느냐에 따라 사각지대 최소가 나오니 재귀문 사용
# depth : 보드에 존재하는 카메라들에 대한 index
def dfs(depth, _board):
    global answer
    # 설치된 cctv 모두를 감시 해봤을 때
    if depth == len(cctvs):
        # do something
        # 사각지대 개수
        result = 0
        for x in range(n):
            # 각 보드 한줄에 0의 개수(사가지대 개수)
            result += _board[x].count(0)
        answer = min(answer, result)
        return
    # 입력 받은 보드판은 원상태로 두고 모니터링해야지 최대 값을 찾는데 영향 X
    new_board = copy.deepcopy(_board)
    mode_num, cx, cy = cctvs[depth]
    # 카메라 번호에서 감시할 수 있는 모드 선택
    for mode in camera_mode[mode_num]:
        monitoring(mode, cx, cy, new_board)
        dfs(depth+1, new_board)
        # 끝난 후에는 다음 카메라를 진행할 때 원본 보드로 바꿔놓아야함
        new_board = copy.deepcopy(_board)


dfs(0, board)
print(answer)
```

