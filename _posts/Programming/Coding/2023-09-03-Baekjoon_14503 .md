---
title:  "[백준]14503번"
categories: Coding
tag: [Coding, Coding Test, Baekjoon, Python, Simulation, Graph]
tags: [Jekyll, MathJax]
toc: true
author_profile: false
sidebar:
    nav: "docs"
use_math: true
date: 2023-09-03
toc_sticky: true
---

## 로봇 청소기(14503번)

<https://www.acmicpc.net/problem/14503>

### 문제

로봇 청소기와 방의 상태가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.

로봇 청소기가 있는 방은 $N \times M$ 크기의 직사각형으로 나타낼 수 있으며, $1 \times 1$ 크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북 중 하나이다. 방의 각 칸은 좌표 $\(r, c\)$로 나타낼 수 있고, 가장 북쪽 줄의 가장 서쪽 칸의 좌표가 (0,0)$(0, 0)$, 가장 남쪽 줄의 가장 동쪽 칸의 좌표가 $\(N-1, M-1\)$이다. 즉, 좌표 $\(r, c\)$는 북쪽에서 $\(r+1\)$번째에 있는 줄의 서쪽에서 $\(c+1\)$번째 칸을 가리킨다. 처음에 빈 칸은 전부 청소되지 않은 상태이다.

로봇 청소기는 다음과 같이 작동한다.

1. 현재 칸이 아직 청소되지 않은 경우, 현재 칸을 청소한다.
2. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 없는 경우,
   1. 바라보는 방향을 유지한 채로 한 칸 후진할 수 있다면 한 칸 후진하고 1번으로 돌아간다.
   2. 바라보는 방향의 뒤쪽 칸이 벽이라 후진할 수 없다면 작동을 멈춘다.
3. 현재 칸의 주변 4칸 중 청소되지 않은 빈 칸이 있는 경우,
   1. 반시계 방향으로 $90^\circ$ 회전한다.
   2. 바라보는 방향을 기준으로 앞쪽 칸이 청소되지 않은 빈 칸인 경우 한 칸 전진한다.
   3. 1번으로 돌아간다.

### 입력

첫째 줄에 방의 크기 $N$과 $M$이 입력된다. $(3 \le N, M \le 50)$  둘째 줄에 처음에 로봇 청소기가 있는 칸의 좌표 $\(r, c\)$와 처음에 로봇 청소기가 바라보는 방향 $d$가 입력된다. $d$가 $0$인 경우 북쪽, $1$인 경우 동쪽, $2$인 경우 남쪽, $3$인 경우 서쪽을 바라보고 있는 것이다.

셋째 줄부터 $N$개의 줄에 각 장소의 상태를 나타내는 $N \times M$개의 값이 한 줄에 $M$개씩 입력된다. $i$번째 줄의 $j$번째 값은 칸 $\(i, j\)$의 상태를 나타내며, 이 값이 $0$인 경우 $\(i, j\)$가 청소되지 않은 빈 칸이고, $1$인 경우 $\(i, j\)$에 벽이 있는 것이다. 방의 가장 북쪽, 가장 남쪽, 가장 서쪽, 가장 동쪽 줄 중 하나 이상에 위치한 모든 칸에는 벽이 있다. 로봇 청소기가 있는 칸은 항상 빈 칸이다.

### 출력

로봇 청소기가 작동을 시작한 후 작동을 멈출 때까지 청소하는 칸의 개수를 출력한다.

### 해결법

visited 처리가 곧 청소 처리와 동일   
로봇 청소기가 놓인 곳을 우선 청소한다(visited 배열을 따로 두어 방문 처리)   
바라보는 방향은 **0: 북, 1: 동, 2: 남, 3: 서** 이렇게 정의되며, 우선 청소할 수 있는 곳인지 확인 하는 작업을 반시계 방향으로 $$90^\cir$ 회전하여 확인함.    
이때, 위의 문제 설명과 같은 조건(3번 조건)인 현 위치에서 방향을 회전하며 청소할 수 있는 칸(아직 visited 미방문, 갈 수 있는 칸)인 경우에 해당 방향으로 회전한 후 이동하여 청소를 진행하면 됨.   
또한, 위의 문제 설명과 같은 조건인(2번 조건) 현재 칸 주변에 모두 청소된 칸이 존재하지 않는 다는 것은 3번조건으로 수행할 수가 없다는 뜻이므로, 우선 3번 조건을 수행하는 부분을 작성 후 해당 3번 조건을 수행하지 못했을시에 대한 flag 변수를 따로 정의하여 해당 flag에 따라 벽이 없는 칸인 경우에는 후진을 한 후 다시 1번 부터 수행, 갈 수 없다면 종료를 하면 해결 가능   

```python
from collections import deque
# 사이즈 입력
n, m = map(int, input().split())
board = []
# 청소 유무 확인
visited = [[False] * m for _ in range(n)]
# 로봇 청소기 시작 위치(r, c), 방향
r, c, d = map(int, input().split())

# 바라보는 방향
# 0: 북, 1: 동, 2: 남, 3: 서
dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

# 보드 입력, 0: 갈 수 있는 곳, 1: 갈 수 없는 곳
for _ in range(n):
    board.append(list(map(int, input().split())))


# CLEAN
def clean(sx, sy, sd):
    q = deque()
    # 초기 위치, 초기 방향을 queue에 삽입
    q.append([sx, sy, sd])
    # 초기 위치 청소
    visited[sx][sy] = True
    while q:
        x, y, d = q.popleft()
        # 2번 조건 : 4칸 모두 빈칸이 없는 경우
        flag = False
        # 1번 수행 : 현 위치를 청소 하지않았다면 청소
        if not visited[x][y]:
            visited[x][y] = True
        for _ in range(4):
            d = (d - 1) % 4
            nx, ny = x+dx[d], y+dy[d]
            # 3번 조건 : 현 바라보는 방향으로 이동할 수 있는 곳인지 확인, 청소되어 있지 않은 경우, 벽(빈칸)이 아닌경우
            if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and board[nx][ny] == 0:
                # 이동
                q.append([nx, ny, d])
                flag = True
                break
            # 반시계 방향 전환
        # 3번 조건 : 이동할 수 없는 경우
        if not flag:
            # 후진
            nx, ny = x - dx[d], y - dy[d]
            # 3-2번 조건인 후진할 수 없는 경우 작동 멈춤
            if board[nx][ny]:
                break
            q.append([nx, ny, d])
clean(r, c, d)
answer = 0
for row in visited:
    answer += (sum(row))
print(answer)
```

